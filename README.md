Team members:
Christos Kontochristos

        Implemented the CHUNK library.
Nikelli Emmanouela

        Implemented the SORT library.
Spiros Karidis

        Implemeted MERGE.


ChatGpt Conversation:
    https://chat.openai.com/share/7b3fb7d9-9d0c-4479-91a6-24a59b8d3fbb

    
Για το Sort:
https://chat.openai.com/share/98b1ba9a-bde4-4f99-b229-e7c42ea10e53

https://chat.openai.com/share/c05bc7d8-c54c-4a86-b984-0a784feefef9

https://chat.openai.com/share/303e4113-6264-49f9-8f58-d2040f17b3ec


General comments:


Για το sort library:
    The changed done to the Sort function generated by ChatGPT were minimal. Specifically changed the comparison operand in shouldSwap so that the sorting is done in ascending order instead of the descending order used initially and changed the condition "if (CHUNK_GetIthRecordInChunk(chunk, i, &records[i]) == 0)" in sort_Chunk to "if (CHUNK_GetIthRecordInChunk(chunk, i, &records[i]) == -1)" so that it matches with the implementation of CHUNK_GetIthRecordInChunk. The rest of the code is the same as the one generated by ChatGPT. Used quicksort as the sorting method.

chunk.c:

All the functions where mostly implemented from ChatGPT with small changes.
The changes are the following:



In CHUNK_Iterator CHUNK_CreateIterator() ChatGPT had initialized the variable iterator.lastBlocksID = 0; and was changed so that it takes the id
of the last block  (using HP_GetIdOfLastBlock) to iterator.lastBlocksID = HP_GetIdOfLastBlock(fileDesc); .



In int CHUNK_GetNext() ChatGPT didn't take into consideration the case of the last chunk so an if case was added for that scenario.
Meaning if last chunk then it initializes the struct correctly since the last chunk may not contain the max ammount of blocks/records 
as the others.



In CHUNK_GetIthRecordInChunk() and CHUNK_UpdateIthRecord() the following changed: 

In lines σε:

int blockId = chunk->from_BlockId + i / HP_GetMaxRecordsInBlock(chunk->file_desc);
int cursor = i % HP_GetMaxRecordsInBlock(chunk->file_desc);

compared to :

int blockId = chunk->from_BlockId + i / BF_BLOCK_SIZE;
int cursor = i % BF_BLOCK_SIZE;

and in line Record *blockRecords = (Record *)(data); compared to Record *blockRecords = (Record *)(data + sizeof(int));

The changes in these 2 functions where the same.



In CHUNK_RecordIterator CHUNK_CreateRecordIterator() simply the added the case where the argument of the function was equal to NULL
so that it's properly handled.



In int CHUNK_GetNextRecord() changed the condition of the 1st nested if case from if (iterator->cursor < BF_BLOCK_SIZE - 1) to
if (iterator->cursor < HP_GetMaxRecordsInBlock(iterator->chunk.file_desc)).


For the sort library:
    The changed done to the functions of Sort produced by ChatGPT were minimal. Specificaly, changed the comparison operator of shouldSwap so that the sorting is done in ascending order instead of the initial descending order and made a change of the condition "if (CHUNK_GetIthRecordInChunk(chunk, i, &records[i]) == 0)" in sort_Chunk to "if (CHUNK_GetIthRecordInChunk(chunk, i, &records[i]) == -1)" so that it matches with the implementation of CHUNK_GetIthRecordInChunk. The rest of the code is the same as the one made by ChatGPT. Additionally quicksort was used as a sorting method.



merge.c

Notied: while the logic of merge() is correct it doesn't function properly.


On the merge function the following changes were done:

On line 152 cahnged to  if (HP_InsertEntry(output_FileDesc, records[i]) != 1)  from if (writeRecordToFile(output_FileDesc, &records[i]) != 0) 

The int totalRecordsInMerge = chunkSize * bWay; changed to int totalRecordsInMerge = chunkSize * HP_GetMaxRecordsInBlock(input_FileDesc) * bWay;

ChatGPT did initialize the recordIterators[] array giving NULL argument to CHUNK_CreateRecordIterator and changed so that every chunk is inserted correctly in the array (lines 103-132).
